| Mutation pass                              | Example before transformation | Example after transformation | Remark                                                                                          |
|--------------------------------------------|------------------------------|-----------------------------|-------------------------------------------------------------------------------------------------|
| Functional equivalent type changes          | uint32_t var_0 = 10;        | int var_0 = 10;             | We will skip this mutator if we are testing queries related to integer overflow                  |
| Rewrite boolean logic to numbers            | return true;                | return 1;                   |                                                                                                 |
| Adding OR logic to if statement             | if(flag){<br>…<br>}         | if(flag \|\| false){<br>…<br>} |                                                                                                 |
| Adding AND logic to if statement            | if(flag){<br>…<br>}         | if(flag && true){<br>…<br>}  |                                                                                                 |
| Result equivalent API rewrite               | malloc(0x10);               | calloc(1,0x10);             |                                                                                                 |
| Rewrite numeric returns 	                  | <br>…<br>return 1;	        | <br>…<br>int ret= 1;<br>ret = ret<<2;<br>return ret/4;	|We will skip this mutator if we are testing query related to integer overflow OR arithmetic
| Rewrite ++ OR --                            | int a = 10;<br>….<br>….<br>a++; | int a = 10;<br>….<br>….<br>a = a + 1; | We will skip the result generated by this mutator if it is related to the number of times the variable exists (here will be a)<br><br>As a remark, we have several other variants for this mutator. Please refer to our source code for details. |
| Adding more reference to a variable TYPE 1   | char *ptr0;                 | char *ptr0;<br>char *ptr1 = &ptr0;<br>char *ptr2 = &ptr0; | We implemented a variant of this mutator for integers                                           |
| Adding more reference to a variable TYPE 2   | char *ptr0 = “A”;           | char *ptr0;<br>char *ptr1 = &ptr0;<br>char *ptr2 = &ptr0;<br>char *ptr3 = &ptr0;<br>*ptr3 = “A”; | We implemented a variant of this mutator for integers                                           |
| Change a local variable to a global variable | int main(){<br>…<br>int a;<br>…<br>… | int a;<br>int main(){<br>…<br>… |                                                                                                 |
| Generate a totally random variable to global | int main(){<br>…<br>}       | int new_var = 100;<br>int main(){<br>…<br>} |                                                                                                 |
| Redefine a variable within a function        | int foo(int a){<br>…<br>a = a+1;<br>…<br>b = a*2;<br>return b;<br>} | int foo(int a){<br>int var_001 = a;<br>var_001  = var_001+1;<br>…<br>b = var_001*2;<br>return b;<br>}<br>OR<br><br>int foo(int a){<br>int& var_001 =a;<br>var_001  = var_001+1;<br>…<br>b = a*2;<br>return b;<br>} |                                                                                                 |
| Embed a statement with a single iteration for loop | int foo(int a){<br>…<br>a = a+1;<br>…<br>b = a*2;<br>return b;<br>} | int foo(int a){<br>…<br>for(int var_1234 = 0; var_1234<1; var_1234++){<br>a = a+1;<br>}<br>…<br>b = a*2;<br>return b;<br>} |                                                                                                 |
| Return numeric variable with max/min         | int foo(int a){<br>…<br>a = a+1;<br>…<br>b = a*2;<br>return b;<br>} | int foo(int a){<br>…<br>a = std::min(a,2147483647)+1;<br>…<br>b = a*2;<br>return b;<br>} |                                                                                                 |
| Return number with max/min                   | int bar(){<br>int a = 10;<br>…<br>return 0;<br>} | int bar(){<br>int a = std::max(10,-2147483648);<br>…<br>return 0;<br>} | We will try to guess the type of the number and return a max or min number based on the guessed type. Manual review for false positive or false negative results generated by this mutator is required. |